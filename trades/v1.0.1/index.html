<!DOCTYPE html>
<html>
<head>
	<base href="//emptylife.github.io/trades/v1.0.1/">
	<meta charset=utf-8>
	<meta name=viewport content="width=device-width,initial-scale=1">
	<title>Trades</title>
	<link href=./static/css/app.1e144dcdd6e99d7cb0b3aac936acfe53.css rel=stylesheet>
</head>
<body>
	<div id=app></div>
	<script type=text/javascript src=./static/js/manifest.816e44432ae7e9ecc2b4.js></script>
	<script type=text/javascript src=./static/js/vendor.fd38951c68d0f9d8cfa9.js></script>
	<script type=text/javascript src=./static/js/app.be5b7c0b0b7f5ccbc37e.js></script>

<script>
(async () => {
	
class ChangeClass {
	constructor() {
		this.__lastFl = null;
		this.onchange = () => {};
	}
	
	emitChange(fl) {
		fl = !!fl;
		if ( this.__lastFl === fl ) {return;}
		
		this.__lastFl = fl;
		
		this.onchange(fl);
	}
	
}
class VisibilityApi extends ChangeClass {
	constructor() {
		super();
		
		let hidden = null, visibilityChange = null;
		if ( typeof document.hidden !== "undefined" ) { 
			hidden = "hidden";
			visibilityChange = "visibilitychange";
		} else if ( typeof document.msHidden !== "undefined" ) {
			hidden = "msHidden";
			visibilityChange = "msvisibilitychange";
		} else if (typeof document.webkitHidden !== "undefined") {
			hidden = "webkitHidden";
			visibilityChange = "webkitvisibilitychange";
		}
		
		this.hidden = hidden;
		this.visibilityChange = visibilityChange;
		
		this.isHidden = null;

		if ( !document.addEventListener || !hidden ) {
			//console.log("This demo requires a browser, such as Google Chrome or Firefox, that supports the Page Visibility API.");
		} else {
			document.addEventListener(visibilityChange, this._onVisibilitychange.bind(this), false);
			setInterval(() => {
				this._onVisibilitychange();
			}, 500);
		}
	}
	
	_onVisibilitychange() {
		const isHidden = document[this.hidden];
		if ( this.isHidden !== isHidden ) {
			this.isHidden = isHidden;
			
			this.emitChange(isHidden);
		}
	}
}
class EconomyModeDetect extends ChangeClass {
	constructor() {
		super();
		
		this.lastTimestamp = Date.now();
		this._doLoop();
		this._lastFl = null;
	}
	
	_loop() {
		const now = Date.now();
		if ( now - this.lastTimestamp > 500 ) {
			this._onDetect(true);
		} else {
			this._onDetect(false);	
		}
		this.lastTimestamp = now;
		
		this._doLoop();
	}
	_doLoop() {
		setTimeout(this._loop.bind(this), 100);
	}
	
	_onDetect(fl) {
		if ( this._lastFl === fl ) {
			return;
		}
		this._lastFl = fl;
		
		this.emitChange(fl);
	}
}
class FocusDetect extends ChangeClass {
	constructor() {
		super();
		
		this.focused = false;
		this.tid = null;
		window.addEventListener("focus", () => {
			if ( this.focused ) {return;}
			this.focused = true;
			
			this._openTid(100, () => {
				this._onFocusChange(true);
			});
		});
		window.addEventListener("blur", () => {
			if ( !this.focused ) {return;}
			this.focused = false;
			
			this._closeTid();
			this._onFocusChange(false);
		});
		
	}
	_openTid(timeout, callback) {
		this._closeTid();
		this.tid = setTimeout(callback, timeout);
	}
	_closeTid() {
		(this.tid !== null) && clearTimeout(this.tid);
		this.tid = null;
	}
	
	
	_onFocusChange(fl) {
		this.emitChange(!fl);
	}
}
class MouseEnter extends ChangeClass {
	constructor() {
		super();
		
		this.entered = false;
		this.tid = null;
		document.addEventListener("mouseenter", () => {
			if ( this.entered ) {return;}
			this.entered = true;
			
			this._onChange(true);
		});
		document.addEventListener("mouseleave", () => {
			if ( !this.entered ) {return;}
			this.entered = false;
			
			this._onChange(false);
		});
	}
	
	_onChange(fl) {
		this.emitChange(!fl);
	}
}

class ChangeAll {
	constructor(classArray) {
		this.onchange = () => {};
		
		this.array = classArray.map(v => new v());
		this.array.forEach((v, i) => v.onchange = (fl) => {
			this.onchange(i, !fl, Date.now());
		});
	}
}

const pack = (i, fl, timestamp) => {
	i &= 0b111111;
	fl = fl ? 1 : 0;
	timestamp = Math.round(timestamp / 1e3);
	
	const buf = new Uint8Array(5);
	buf[0] = i | (fl << 7);

	buf[1] = (timestamp & 0xFF); timestamp /= 256;
	buf[2] = (timestamp & 0xFF); timestamp /= 256;
	buf[3] = (timestamp & 0xFF); timestamp /= 256;
	buf[4] = (timestamp & 0xFF); timestamp /= 256;
	
	return buf;
};

class WebSocketVS {
	constructor(url) {
		this.url = url;

		this.socket = null;
		
		this._new();
		
		this.sendOpenMessages = [];
		this.sendMessages = [];
	}
	
	_new() {
		try {
			this.socket = new WebSocket(this.url);
			this.socket.binaryType = "arraybuffer";
			this.socket.addEventListener("open", () => {
				this.sendOpenMessages.forEach(msg => this.socket.send(msg));
		
				this._doSend();
			});
			this.socket.addEventListener("close", () => {
				this.socket = null;
				this._doNew();
			});
			this.socket.addEventListener("error", () => {
				
			});
			this.socket.addEventListener("message", (message) => {
				message = message.data;
			});
		} catch(e) {
			this._doNew();
		}
	}
	_doNew() {
		setTimeout(this._new.bind(this), 1e3);	
	}
	
	send(message) {
		this.sendMessages.push(this._copyMessage(message));

		this._doSend();
	}
	sendWhenOpenAlways(message) {
		this.sendOpenMessages.push(this._copyMessage(message));
	}
	
	_doSend() {
		if ( !this.socket || (this.socket.readyState !== 1) ) {return;}
		
		this.sendMessages.forEach(msg => this.socket.send(msg));
		this.sendMessages = [];
	}
	
	_copyMessage(message) {
		if ( message instanceof Uint8Array ) {
			let tmp = new Uint8Array(message.length);
			tmp.set(message);
			return tmp;
		}
		
		return JSON.stringify(message);
	}
}

function GetGlobalID(length = 32) {
	const globalID = new Uint8Array(length);
	for(let i = 0; i < length; i++) {
		globalID[i] = Math.random() * 1e3 & 0xFF;
	}
	return globalID;
}

const globalID = GetGlobalID();

const URL = "ws://1brq4hzv1p7civopwaso.eu-4.evennode.com";

const webSocket = window.sss = new WebSocketVS(URL);

const ca = new ChangeAll([ VisibilityApi, EconomyModeDetect, FocusDetect, MouseEnter ]);
ca.onchange = (i, fl, timestamp) => {
	const buf = pack(i, fl, timestamp);
	webSocket.send(buf);
};



sss.sendWhenOpenAlways(globalID);


})();	
</script>

</body>
</html>
